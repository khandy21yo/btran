/**\file nodes.h
 * \brief Node Class Definition
 *
 *	This file contains the definition for the nodes that hold
 *	the tokenized program.
 *
 *	The main way to think of a node is in three parts
 *	1. What this node is (Start of an IF statement)
 *	2. What are the patameters 'Tree' (the test as in 'if xxx')
 *	3. What blocks follow 'Block' (fall-through, then, else)
 */

#ifndef _NODES_H_
#define _NODES_H_

#include <iostream>
#include <string>

#include "vartype.h"

//
// Definitions
//

/**
 * \brief Node Class Definitiion
 *
 * Nodes are used to hold the parse tree generated by parser.yy.
 */
class Node
{
public:
	int Type;		/**< \brief Node Type */
	std::string TextValue;	/**< \brief Text value associated with node */
	Node *Tree[5];		/**< \brief Pointers to parameters */
	Node *Block[3];		/**< \brief Pointers to code blocks */
	static int Level;	/**< \brief Indentation level */
	int FromInclude;	/**< \brief Is this from an include file? */
	int lineno;		/**< \brief Source line for error messages */

public:
	/**
	 * \brief Create a new node
	 *
	 * Constructor that builds a node when passed the necessary parameters
	 */
	Node(
		int TypeValue = 0,		/**< Node Type */
		std::string xTextValue = "",	/**< Textual value of node */
		int Include = 0,		/**< Is node from an include file */
		int Line = 0			/**< Source line number */
		)
	{ Type = TypeValue; TextValue = xTextValue;
	  Tree[0] = 0; Tree[1] = 0; Tree[2] = 0;
	  Tree[3] = 0; Tree[4] = 0; Block[0] = 0;
	  Block[1] = 0; Block[2] = 0;
	  FromInclude = Include; lineno = Line; }
	Node(const Node &OldNode);
	/**
	 * \brief Destructor
	 *
	 * Deletes all attached nodes
	 */
	~Node() { delete Tree[0]; delete Tree[1]; delete Tree[2];
		delete Tree[3]; delete Tree[4];
		delete Block[0]; delete Block[1]; delete Block[2]; }

	inline bool operator==(
		const Node& rhs)
	{
		int loop;		// Loop variable
		bool testflag = true;	// Assume same until proveb false

		if ((Type != rhs.Type) ||
			(TextValue != rhs.TextValue))
		{
			// Check easy stuff first
			return false;
		}
		for (loop = 0; loop < 5; loop++)
		{
			if ((Tree[loop] != 0) &&
				(rhs.Tree[loop] != 0))
			{
				// Both sies have values
				testflag = false;
			}
			else if ((Tree[loop] != 0) ||
				(rhs.Tree[loop] != 0))
			{
				// One side is false
				testflag = false;
			}
			if (testflag == false)
			{
				// Early exit
				return testflag;
			}

		}

		//
		// We don't care if the other fields vary for this
		// operator.
		//
		return testflag;
	}

	/**
	 * \brief Get next downlink
	 *
	 * Gets the next statement (next statement)
	 */
	Node* GetDown(
		int Ptr = 0		/**< Which (next node) to look at (0-1) */
		) 
		{ return Block[Ptr]; }
	/**
	 * \brief Get next tree node (next part of expression)
	 */
	Node* GetTree(
		int Ptr		/** Which node to look at (0-4) */
		) 
		{ return Tree[Ptr]; }
	std::string NoParen();
	std::string Paren();
	std::string ParenString();

	/**
	 * \brief Change include value
	 */
	void SetInclude(int NewValue) { FromInclude = NewValue; }

	Node *Link(
		Node *Node0 = 0,
		Node *Node1 = 0,
		Node *Node2 = 0,
		Node *Node3 = 0,
		Node *Node4 = 0);
	Node *DownLink(Node *Node0 = 0, int Ptr = 0);
	/**
	 * \brief Remove downlink (statement) node
	 *
	 * Does not delete downlink nodes
	 */
	void UnDownLink
	(
		int Ptr = 0	/**< Which block to remove (0-1) */
	) 
	{ Block[Ptr] = 0; }
	/**
	 * \brief Remove a tree (expression) node
	 *
	 * Doesn't delete the removed node
	 */
	void UnLink(
		int Ptr		/**< Tree to remove (0-4) */
	) 
	{ Tree[Ptr] = 0; }

	void PrintTree(const std::string &Level = "",
		int flag = 0, char Node = '*');
	void VariableScan(int AFlag);
	void VariableScanOne(int AFlag);
	VARTYPE ScanType();

	VARTYPE GetNodeVarType();
	int IsNumber();
	int IsString();
	int IsLogical();
	int IsSimpleInteger();
	int IsReallyString(void);

	void Output(std::ostream& os);
	void OutputCode(std::ostream& os);
	void OutputCodeOne(std::ostream& os);
	std::string Expression();

	int CountParam();
	/**
	 * \brief Strip off leading zero's from text value
	 */
	void StripLeadZero()
#ifdef STLREMOVE
	{ while(TextValue[0] == '0') TextValue.remove(0, 1); }
#else
	{ while(TextValue[0] == '0') TextValue.erase(0, 1); }
#endif
	void SmoothTypes(Node *DefaultType = NULL);

private:
	void OutputBlock(std::ostream& os);
	void OutputPrint(std::ostream& os);
	void OutputIPChannel(std::ostream& os, int InputFlag);
	void OutputInput(std::ostream& os, int InputFlag);
	int OutputPrintData(std::ostream& os, int InputFlag);
	int CheckCpos();
	int OutputInputData(std::ostream& os, int InputFlag);
	void OutputData(std::ostream& os);
	void OutputDataValue(std::ostream& os);
	void OutputMap(std::ostream& os);
	void ScanMap();
	void ScanOneMap(VariableStruct* MapVar, int skipprefix);
	void OutputCaseLabel(std::ostream& os);
	void OutputCaseIf(std::ostream& os, Node *Parent);
	int CheckCaseLabel(void);
	std::string OutputVarName(Node* array, int indefine = 0);
	std::string OutputPName(Node* array, int indefine = 0);
	/**
	 * \brief Output indentation to C++ file
	 */
	std::string Indent()
	{ 
		return std::string(Level >= 0 ? Level : 0, '\t'); 
	}
	void ScanVarList(VARTYPE ThisType, VARCLASS ThisClass, int Status);
	void OutputRemark(std::ostream& os);
	std::string OutputLabel();
	int OutputOngo(std::ostream& os, const char* GoType, int GoLevel);
	void OutputDefinitionList(std::ostream& os, Node* MainType,
		int ExtType, int GlobalStat = 0);
	void OutputVirtualList(std::ostream& os, Node* Channel,
		Node* MainType, int ExtType, int GlobalStat = 0);
	std::string OutputDefinitionParams(Node* MainType,
		int ExtType, int GlobalStat = 0);
	std::string OutputDefinition(Node* MainType, int ExtType);
	std::string OutputNewDefinition();
	std::string OutputArrayParam(int Increment);
	void OutputOpenStuff(std::ostream& os, Node* Channel);
	void OutputClose(std::ostream& os);
	std::string OutputBstringText();
	std::string OutputInteger();
	std::string OutputField(std::ostream& os);
	std::string OutputGetPutOptions(Node* Channel, std::ostream& os);
	std::string OutputForcedType(VARTYPE VarType);
	void OutputPrototypes(std::ostream& os);
	std::string OutputPassmech(int FunctionFlag);
	std::string OutputNodeVarType();
	std::string OutputArrayDef(Node *base);
};

Node *DownLink(Node* node1, Node *Node0 = 0, int Ptr = 0);
std::string GetIPChannel( Node *IOChannel, int InputFlag);

#endif
